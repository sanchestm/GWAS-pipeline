 def report(self, round_version: str = '10', threshold: float = 5.3591, suggestive_threshold: float = 5.58, 
               covariate_explained_var_threshold: float = 0.02, gwas_version='current'):
    with open(f'{self.path}genotypes/parameter_thresholds.txt', 'r') as f: 
        out = f.read()
        params = {x:re.findall(f"--{x} ([^\n]+)", out)[0] for x in ['geno', 'maf', 'hwe']}
    with open(f'{self.path}genotypes/genotypes.log') as f:
        out = f.read()
        params['snpsb4'] = re.findall(f"(\d+) variants loaded from .bim file.", out)[0]
        params['snpsafter'], params['nrats'] = re.findall("(\d+) variants and (\d+) samples pass filters and QC.", out)[0]
        params['removed_geno'], params['removedmaf'], params['removedhwe'] = \
               (~pd.read_parquet(f'{self.path}genotypes/snpquality.parquet.gz')[['PASS_MISS','PASS_MAF','PASS_HWE']])\
               .sum().astype(str)
                
    text_sidepanel = f"""# General Information
<hr>

Phenotype Info

* n = *{params['nrats']}*

* phenotype data: [here](https://palmerlab.s3.sdsc.edu/tsanches_dash_genotypes/gwas_results/{self.project_name}/processed_data_ready.csv)

* covariate dropboxes: [here](https://palmerlab.s3.sdsc.edu/tsanches_dash_genotypes/gwas_results/{self.project_name}/data_dict_{self.project_name}.csv) 

* phenotype statistical descriptions file: [here](https://palmerlab.s3.sdsc.edu/tsanches_dash_genotypes/gwas_results/{self.project_name}/data_distributions.html) 
<hr>

Genotype Info

* genotypes version: \n*{round_version}*

* gwas pipeline version: \n*{gwas_version}*

* number of snps: \nbefore filter *{params['snpsb4']}*, \nafter filter *{params['snpsafter']}*

* genotype missing rate filter: < *{params['geno']}* \n(*{ params['removed_geno']}* snps removed)

* minor allele frequency filter: > *{params['maf']}* \n(*{params['removedmaf']}* snps removed)

* hardy-weinberg equilibrium filter: < *{params['hwe']}* \n(*{params['removedhwe']}* snps removed)
    """
    
    template = pn.template.BootstrapTemplate(title=f'GWAS REPORT')
    # Add components to the sidebar, main, and header
    template.sidebar.extend([
    pn.pane.Alert(text_sidepanel, alert_type="primary")
    ])
    ##### adding data dictionary
    dd = pd.read_csv(f'data_dict_{self.project_name}.csv').fillna('')\
       [['measure', 'trait_covariate','covariates', 'description']]\
       .query("measure != ''")
    template.main.append( pn.Card('Collaborative data dictionary google document: ',
                                  fancy_display(dd), title = 'Trait Descriptions', collapsed=True))
    
    explained_vars =  pd.read_csv('melted_explained_variances.csv').pivot(columns = 'group', values='value', index = 'variable')
    fig_exp_vars = px.imshow(explained_vars, text_auto=True, aspect="auto", color_continuous_scale='Reds')
    fig_exp_vars.update_layout(template = 'simple_white', width=800,height=800,autosize=False)
    
    g0 = px.imshow(self.df.set_index('rfid')[self.traits].rename(lambda x: x.replace('regressedlr_', ''), axis = 1), aspect = 3, color_continuous_scale='RdBu')
    g0.update_layout(  width=1000, height=1400,autosize=False,showlegend=False, template='simple_white',plot_bgcolor='black')
    g1df = self.df.set_index('rfid')[list(map(lambda x: x.replace('regressedlr_', ''), self.traits))]
    g1df.loc[:, :] = StandardScaler().fit_transform(g1df)
    g1 = px.imshow(g1df, aspect = 3, color_continuous_scale='RdBu')
    g1.update_layout(  width=1000, height=1400,autosize=False,showlegend=False, template='simple_white',plot_bgcolor='black')
    
    cov_text = '''Covariates may confound the results of the analysis. Common covariates include “age”, “weight”, “coat color”, “cohort”, and “phenotyping center”. We work with individual PIs to determine which covariates should be considered. In order to “regress out” the part of the phenotypic variance that is related to known covariates, we follow the procedure of fitting a linear model that predicts the desired trait based only on the measured covariates. Then the trait is subtracted by the trait predictions generated by the linear model described above. The resulting subtraction is expected to be independent of the covariates as all the effects caused by those covariates were removed. Since this method utilizes a linear regression to remove those effects, non-linear effects of those covariates onto the traits will not be addressed and assumed to be null. In certain cases, it’s possible that accounting for too many covariates might ‘overcorrect’ the trait. To address this issue, we ‘regress out’ only the covariates that explain more than REGRESSTHRS of the variance of the trait. This calculation is often called r^2 or pve (percent explained variance) and is estimated as cov (covariant, trait)/variance(trait). Lastly, the corrected trait is quantile normalized again, as it’s expected to follow a normal distribution. For time series regression we use the prophet package (https://facebook.github.io/prophet/) that uses a generalized additive model to decompose the timewise trend effects and covariates onto the mesurement of animal given its age. Because age might affect differently males and females, we first groupby the animals between genders before using the timeseries regression to remove covariate effects. After removing the covariate effects in with the timeseries regression, we then quantile normalize the residuals to be used for subsequent analysis.''' 
    cov_card = pn.Card( pn.Card(cov_text, pn.pane.Plotly(fig_exp_vars), title = 'Covariate effects', collapsed=True),
                        pn.Card(pn.Swipe(pn.pane.Plotly(g1),pn.pane.Plotly(g0)), title = 'Preprocessing effect', collapsed=True),
                       title = 'Preprocessing', collapsed=True)
    template.main.append( cov_card)
    #pn.pane.Matplotlib(g1.figure, dpi = 50)
    
    gcorrtext = '''
    # *Genetic Correlation Matrix*
    
    Genetic correlation is a statistical concept that quantifies the extent to which two traits share a common genetic basis. The estimation of genetic correlation can be accomplished using Genome-wide Complex Trait Analysis (GCTA), a software tool that utilizes summary statistics from genome-wide association studies (GWAS) to estimate the genetic covariance between pairs of traits. GCTA implements a method that decomposes the total phenotypic covariance between two traits into genetic and environmental components, providing an estimate of the genetic correlation between them. This approach allows researchers to examine the degree of shared genetic architecture between traits of interest and gain insights into the biological mechanisms underlying complex traits and diseases. 
    
    For the figure, the upper triangle represents the genetic correlation (ranges from [-1:1]), while the lower triangle represents the phenotypic correlation. Meanwhile the diagonal displays the heritability (ranges from [0:1]) of the traits. Hierarchical clustering is performed using [scipy's linkage function](https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.linkage.html) with the genetic correlation. Dendrogram is drawn using [scipy dendrogram](https://docs.scipy.org/doc/scipy/reference/generated/scipy.cluster.hierarchy.dendrogram.html) where color coding for clusters depends on a distance threshold set to 70% of the maximum linkage distance. Asterisks means that test failed, for genetic relationship the main failure point is if the 2 traits being tested are colinear, while for the phenotypic correlation it's due to no overlapping rats between the 2 traits.
    
    '''
    gcorrfig = pn.pane.PNG(f'{self.path}images/genetic_correlation_matrix.png', max_width=1000, max_height=1000, width = 1000, height = 1000)
    gcorr = pd.read_csv(f"{self.path}results/heritability/genetic_correlation_melted_table.csv", index_col=0).applymap(lambda x: round(x, 3) if type(x) == float else x.replace('regressedlr_', ''))
    gcorr = fancy_display(gcorr)
    template.main.append( pn.Card(gcorrtext, gcorrfig, pn.Card(gcorr, title = 'tableView', collapsed=True),title = 'Genetic Correlation', collapsed=True))
    
    
    heritext = '''
    # **SNP Heritability Estimates h<sup>2</sup>** 
    
    
    SNP heritability (often reported as h<sup>2</sup> ) is the fraction of phenotypic variance that can be explained by the genetic variance measured from the Biallelic SNPS called by the genotyping pipeline. It is conceptually similar to heritability estimates that are obtained from panels of inbred strains (or using a twin design in humans), but SNP heritability is expected to be lower.  Specifically, this section shows the SNP heritability (“narrow-sense heritability”) estimated for each trait by GCTA-GREML, which uses the phenotypes and genetic relatedness matrix (GRM) as inputs. Traits with higher SNP heritability are more likely to produce significant GWAS results. It is important to consider both the heritability estimate but also the standard error; smaller sample sizes typically have very large errors, making the results harder to interpret. 
    Note that Ns for each trait may differ from trait to trait due to missing data for each trait. 
    
    
    Column definitions: 
    
    
    * trait: trait of interest
    * N: number of samples (rats) containing a non-NA value for this trait
    * heritability: quantifies the proportion of phenotypic variance of a trait that can be attributed to genetic variance
    * heritability_se: standard error, variance that is affected by N and the distribution of trait values
    * pval: probability of observing the estimated heritability under the NULL hypothesis (that the SNP heritability is 0) 
    '''
    
    herfig = pn.pane.Plotly(plotly_read_from_html(f'{self.path}images/heritability_sorted.html'))
    her = pd.read_csv(f'{self.path}results/heritability/heritability.tsv', sep = '\t')\
         .set_axis(['trait', 'gen_var', 'env_var', 'phe_var', 'heritability', 'likelihood', 'lrt', 'df', 'pval', 'n', 'heritability_se'], axis = 1)
    her.trait =her.trait.str.replace('regressedlr_', '')
    her = fancy_display(her)
    template.main.append( pn.Card(heritext, herfig, her, title = 'Heritability', collapsed=True))
    
    qtlstext = f'''
    # **Summary of QTLs** 
    
    The genome-wide significance threshold (-log10p): 
    
    * round 10 10%: {round(threshold, 2)}
    * round 10 5% : {round(suggestive_threshold, 2)}
    
    The values shown in the table below pass the round 10 subjective threshold. 
    
      Quantitative trait loci (QTLs) are regions in the genome that contain single nucleotide polymorphisms (SNPs) that correlate with a complex trait.
    If there are multiple QTLs in a given chromosome, then the top SNP from the most significant QTL is used as a covariate for another GWAS analysis within the chromosome.  If the analysis results in another SNP with a p-value that exceeds the permutation-derived threshold then it is considered an independent locus. This continues until no more QTLs are devoted within a given chromosome. This method is described in details in (Chitre et al., 2020)
    
    
    Column definitions: 
    
    
    * TopSNP: SNPs with lowest p-value whithin an independent QTL. SNP name is defined by the location of the top SNP on the chromosome. Read it as follows chromosome: position, so 10:10486551 would be chromosome 10, location on the chromosome at 10486551
    * af: frequency of the TopSNP in the rats used for this study
    * beta: effect size of topSNP
    * betase: standard error of effect size of topSNP
    * -Log10(p): statistical significance of the association between the trait variability and the top SNP, displayed as -log10(p-value). The log-transformed p-value used in all figures and tables in this report
    * trait: trait in which the snp was indentified
    * ACI, BN, BUF, F344, M520, MR, WKY, WN: genotypes of founders at the topSNP
    '''
    
    qtls = pd.read_csv(f'{self.path}results/qtls/finalqtl.csv').query('QTL').rename({'p':'-Log10(p)', 'b':'beta', 'se': 'betase', 'af': 'Freq', 'SNP': 'TopSNP'}, axis = 1).round(3)
    qtls = qtls[['TopSNP','Freq','beta','betase','-Log10(p)','significance_level','trait'] + \
                (['ACI', 'BN', 'BUF', 'F344', 'M520', 'MR', 'WKY', 'WN'] if 'ACI' in qtls.columns else []) ]
    template.main.append( pn.Card(qtlstext, fancy_display(qtls), title = 'QTL', collapsed=True))
    
    
    porcupinetext = '''# **Porcupine Plot**
    
    Porcupine plot is a graphical tool that combines multiple Manhattan plots, each representing a single trait, into a single plot. The resulting plot provides a visual representation of the regions of the genome that influence multiple traits, enabling researchers to identify genetic loci that have pleiotropic effects. These plots allow for a quick and efficient analysis of multiple traits simultaneously. For the porcupine plots shown below, only traits with at least one significant QTL are shown.
    '''
    
    porcfig = pn.pane.PNG(f'{self.path}images/porcupineplot.png', max_width=1000, max_height=600, width = 1000, height = 600)
    template.main.append( pn.Card(porcupinetext, porcfig, title = 'Porcupine Plot', collapsed=True))
    
    
    manhattantext = f'''# **Manhattan plots (for significant QTLS)**
    
    These Manhattan plots show QTLs that genome-wide significance threshold of {round(threshold, 2)}% (10%FPR) in red and high significance {round(suggestive_threshold, 2)}% (5%FPR) in blue. 
    
    The Manhattan plot displays the p-values of each SNP sampled, with the aim of finding specific SNPs that pass the significance threshold. The x-axis shows chromosomal position and the y-axis shows -log10 of the p-value. The GWAS analysis uses a linear mixed model implemented by the software package GCTA (function MLMA-LOCO) using dosage and genetic relatedness matrices (GRM) to account for relatedness between individuals in the HS rat population. The analysis also employs Leave One Chromosome Out (LOCO) to avoid proximal contamination. 
    
    The genomic significance threshold is the genome-wide significance threshold calculated using permutation test, and the genotypes at the SNPs with p-values exceeding that threshold are considered statistically significantly associated with the trait variance. Since traits are quantile-normalized, the cutoff value is the same across all traits. QTLs are determined by scanning each chromosome for at least a SNP that exceeds the calculated permutation-derived threshold.
    
    To control type I error, we estimated the significance threshold by a permutation test, as described in (Cheng and Palmer, 2013).'''
    
    manhatanfigs = [pn.Card(pn.pane.PNG(f'{self.path}images/manhattan/regressedlr_{trait}.png', max_width=1000, 
                 max_height=500, width = 1000, height = 500), fancy_display(qtls.query('trait == @trait')), title = trait, collapsed = True) for trait in qtls.trait.unique()]
    
    manhatanfigs2 = [pn.Card(pn.pane.PNG(f'{self.path}images/manhattan/regressedlr_{trait}.png', max_width=1000, 
                 max_height=500, width = 1000, height = 500), title = trait, collapsed = True) \
                    for trait in set(map(lambda x: x.replace('regressedlr_', ''), self.traits)) - set(qtls.trait)]
    
    
    
    template.main.append( pn.Card(manhattantext, 
                                  pn.Card(*manhatanfigs, title='Plots with QTLs', collapsed=True),
                                  pn.Card(*manhatanfigs2, title='Plots without QTLs', collapsed=True),
                                  title = 'Manhattan Plots', collapsed=True))
    
    PROJECTLIST = '\n'.join(list(map(lambda x: '*  ' + x, pd.read_parquet(self.phewas_db)['project'].unique())))
    regional_assoc_text = f'''
    # **Regional Association plots**
    
    Where Manhattan Plots show SNPs associated with all the chromosomes, a Regional Association Plot zooms in on particular regions of a chromosome that contains a QTL for a given trait. The x-axis represents the position on a chromosome (in Mb) and the y-axis shows the significance of the association (-log10 p-value). The individual points represent SNPs, where the SNP with the lowest p-value (“top SNP”) is highlighted in purple. The colors represent the correlation, or level of linkage disequilibrium (LD), between the topSNP and the other SNPs. The LD was measured with [plink](https://www.cog-genomics.org/plink/1.9/ld) (raw inter-variant allele count squared correlations).
    
    Linkage disequilibrium intervals for the remaining QTLs are determined by finding markers with at least r2=0.6 correlation with the peak marker.
    
    ## Phenotype Wide Association Study (PheWAS): 
    
    These tables report the correlation between the topSNP and traits from other studies in HS rats conducted by the center. Use information from these tables to better understand what additional phenotypes this interval may be associated with. 
    
    The first PheWAS table shows information about any other phenotypes that are associated with this topSNP, from all studies conducted in HS rats by the center.
    
    Defining columns: 
    
    * -Log10(p)PheDb: -log10(p-value) for another trait present in the PheWAS database
    * trait_PheDb: trait from the associated study with the same topSNP
    * project: project from which the trait was studied
    * trait_description_PheDb: trait definition
    
    The second PheWAS table examines the association between the topSNP for this phenotype and all other topSNPs that were mapped within a 3 Mb window of the topSNP from the current study and a correlation above 0.6. Instead of showing association of the topSNP with other traits like in the first table, the second table shows significant association identified for other traits within the nearby chromosomal interval.
    
    Projects included in the PheWAS analysis (see project_name column in PheWAS tables). 
    
    {PROJECTLIST}
    
    Defining columns: 
    
    * SNP_PheDb: SNP from Phewas database in LD with topSNP detected from GWAS  
    * -Log10(p)PheDb: -log10(p-value) for trait from the associated study
    * trait_PheDb: trait from the associated study with the same topSNP
    * project: project from which the trait was studied
    * trait_description_PheDb: trait definition
    * R2: correlation between SNP from phewas database (P-value threshold of 1e-4) and the topSNP for the current study
    * DP: Dprime measure of linkage disequilibrium (correlation between the SNPs adjusted by the maximum possible correlation between those SNPs)
    
    ## Gene Expression changes:
    
    ### expression QTL (eQTLs) 
    We examine if the identified SNP does significant alter the gene expression of genes in cis, possibly describing a pathway in which the SNP impact the phenotype. We also examine SNPs within 3 Mb window and a correlation above 0.6 of the topSNP from the current study, in case the selected SNP is in high LD with another SNP that can alter the gene expression in cis.
    
    Defining columns:
    
    
    * SNP_eqtldb: SNP from eQTL database in LD with topSNP detected from GWAS 
    * -Log10(p)_eqtldb: -log10(p-value) for the association between the eqtlSNP and the gene in cis described in the column Ensembl_gene
    * tissue: tissue in which the gene expression patterns were measured
    * R2: correlation between SNP from eQTL database (P-value threshold of 1e-4) and the topSNP for the current study
    * DP: Dprime measure of linkage disequilibrium (correlation between the SNPs adjusted by the maximum possible correlation between those SNPs)
    * gene: Gene where the SNP_eqtldb influences the gene expression
    * slope: Effect size of the SNP_eqtldb onto the Ensembl_gene
    * af: allele frequency of the SNP_eqtldb
    
    
    ### splice QTL (sQTLs) 
    We examine if the identified SNP does significant alter the splicing patterns of genes in cis, possibly describing a pathway in which the SNP impact the phenotype. We also examine SNPs within 3 Mb window and a correlation above 0.6 of the topSNP from the current study, in case the selected SNP is in high LD with another SNP that can alter the splicing in cis.
    
    Defining columns:
    
    
    * SNP_sqtldb: SNP from sQTL database in LD with topSNP detected from GWAS 
    * -Log10(p)_sqtldb: -log10(p-value) for the association between the sqtlSNP and the gene in cis described in the column Ensembl_gene
    * tissue: tissue in which the splice patterns were measured
    * R2: correlation between SNP from sQTL database (P-value threshold of 1e-4) and the topSNP for the current study
    * DP: Dprime measure of linkage disequilibrium (correlation between the SNPs adjusted by the maximum possible correlation between those SNPs)
    * gene: Gene where the SNP_sqtldb influences the gene expression
    * slope: Effect size of the SNP_sqtldb onto the Ensembl_gene
    * af: allele frequency of the SNP_sqtldb
    
    '''
    
    ann = pd.read_csv(f'{self.path}results/qtls/possible_causal_snps.tsv', sep = '\t').drop(['A1','A2', 'featureid', 'rank', 
                                                                           'cDNA_position|cDNA_len','CDS_position|CDS_len',
                                                                           'Protein_position|Protein_len','distancetofeature'], axis = 1)\
             .query("putative_impact in ['MODERATE', 'HIGH']")
    ann['p'] = -np.log10(ann.p)
    ann.rename({'p':'-Log10(p)'},axis=1,  inplace=True)
    ann
    
    phewas_exact = pd.read_csv(f'{self.path}results/phewas/pretty_table_exact_match.tsv', sep = '\t').rename({ 'p_PheDb':'-Log10(p)PheDb'}, axis =1)\
                     .sort_values('uploadeddate', ascending = False).drop(['round_version', 'uploadeddate'], axis =1).drop_duplicates(['SNP','trait_QTL','trait_PheDb','project'])
    
    phewas = pd.read_csv(f'{self.path}results/phewas/pretty_table_window_match.tsv', sep = '\t').rename({'p_PheDb': '-Log10(p)PheDb'}, axis =1)\
                     .sort_values('uploadeddate', ascending = False).drop(['round_version', 'uploadeddate'], axis =1)\
                     .drop_duplicates(['SNP_QTL', 'SNP_PheDb','trait_QTL','trait_PheDb','project'])
    
    eqtl = pd.read_csv(f'{self.path}results/eqtl/pretty_eqtl_table.csv')\
             .rename({'-log10(P-value)':'-Log10(p)', '-log10(pval_nominal)': '-Log10(p)_eqtldb' }, axis =1)
    
    
    sqtl = pd.read_csv(f'{self.path}results/sqtl/pretty_sqtl_table.csv')\
             .rename({'-log10(P-value)':'-Log10(p)', '-log10(pval_nominal)': '-Log10(p)_sqtldb' }, axis = 1)
    
    genes_in_range = pd.read_csv(f"{self.path}results/qtls/genes_in_range.csv")
    
    out = []
    for index, row in tqdm(list(qtls.iterrows())):
        texttitle = f"Trait: {row.trait} SNP: {row.TopSNP}\n"
        row_desc = fancy_display(row.to_frame().T)
        snp_doc = row.TopSNP.replace(":", '_')
        giran = pn.Card(pn.pane.Markdown( ' '.join(genes_in_range[~genes_in_range.markdown.str.contains('LOC|RGD')].query('SNP_origin == @row.TopSNP').markdown.unique())), 
                        title = 'Gene Links', collapsed = True)
        #lzplot = pn.pane.Plotly(plotio.read_json(f'{self.path}images/lz/lz__{row.trait}__{snp_doc}.json'))
        lzplot = pn.pane.PNG(f'{self.path}images/lz/lz__{row.trait}__{snp_doc}.png',  max_width=1000, max_height=600, width = 1000, height = 600)
        lztext = pn.pane.Markdown(f'[interactive version](https://palmerlab.s3.sdsc.edu/tsanches_dash_genotypes/gwas_results/{self.project_name}/images/lz/lz__{row.trait}__{snp_doc}.html)')
        boxplot = pn.pane.PNG(f'{self.path}images/boxplot/boxplot{snp_doc}__{row.trait}.png', max_width=1000, max_height=600, width = 1000, height = 600)
    
        cau_title = pn.pane.Markdown(f"### Putatively causal coding variants: {row.trait} {row.TopSNP}\n")
        try:cau = ann.query('SNP_qtl == @row.TopSNP and trait == @row.trait')[['SNP','Freq','b','-Log10(p)','R2','DP','annotation','putative_impact','gene','HGVS.c','HGVS.p']].drop_duplicates()
        except:cau = ann.query('SNP_qtl == @row.TopSNP and trait == @row.trait').drop_duplicates()
        if cau.shape[0]: cau = fancy_display(cau)
        else: cau = pn.pane.Markdown(' \n HIGH or MODERATE impact variants absent \n   \n')
    
        phe_title = pn.pane.Markdown(f"### PheWAS: P-values for other phenotypes at trait topSNP: {row.trait} {row.TopSNP}\n")
        phetemp = phewas_exact.query('SNP == @row.TopSNP and trait_QTL == @row.trait')[['-Log10(p)PheDb' ,'trait_PheDb', 'project', 'trait_description_PheDb']].drop_duplicates()
        if phetemp.shape[0]: phetemp = fancy_display(phetemp)
        else: phetemp = pn.pane.Markdown(' \n SNPS were not detected for other phenotypes at this SNP \n   \n')
    
        phew_title = pn.pane.Markdown(f"### PheWAS: Lowest P-values for other phenotypes in a 3Mb window of {row.trait} {row.TopSNP}\n")
        phewtemp = phewas.query('SNP_QTL == @row.TopSNP and trait_QTL == @row.trait')[['SNP_PheDb','-Log10(p)PheDb','R2', 'DP' ,'trait_PheDb', 'project', 'trait_description_PheDb']].drop_duplicates()
        if phewtemp.shape[0]: phewtemp = fancy_display(phewtemp)
        else: phewtemp = pn.pane.Markdown(' \n SNPS were not detected for other phenotypes in 3Mb window of trait topSNP  \n   \n')
    
        eqtl_title = pn.pane.Markdown(f"### eQTL: Lowest P-values for eqtls in a 3Mb window of {row.trait} {row.TopSNP}\n")
        eqtltemp = eqtl.query(f'SNP == "{"chr"+row.TopSNP}" and trait == "@row.trait"').rename({'Ensembl_gene': 'gene'}, axis = 1)\
                       [['SNP_eqtldb', '-Log10(p)_eqtldb', 'tissue', 'R2', 'DP', 'gene', 'gene_id', 'slope', 'af']].drop_duplicates()
        if eqtltemp.shape[0]: eqtltemp = fancy_display(eqtltemp)
        else: eqtltemp = pn.pane.Markdown(' \n SNPS were not detected for eQTLs in 3Mb window of trait topSNP  \n   \n')
    
        sqtl_title = pn.pane.Markdown(f"### sQTL: Lowest P-values for splice qtls in a 3Mb window of {row.trait} {row.TopSNP}\n")
        sqtltemp = sqtl.query(f'SNP=="{"chr"+row.TopSNP}" and trait == "{row.trait}"').rename({'Ensembl_gene': 'gene'}, axis = 1)\
                       [['SNP_sqtldb', '-Log10(p)_sqtldb', 'tissue','R2', 'DP', 'gene','gene_id' , 'slope', 'af']].drop_duplicates()
        if sqtltemp.shape[0]: sqtltemp = fancy_display(sqtltemp)
        else: sqtltemp = pn.pane.Markdown(' \n  SNPS were not detected for sQTLs in 3Mb window of trait topSNP  \n   \n')
    
        out += [pn.Card(*[row_desc,lzplot,lztext,giran, boxplot,pn.Card(cau_title, cau,phe_title, 
                          phetemp, phew_title, phewtemp,eqtl_title, eqtltemp,sqtl_title, sqtltemp, title = 'tables', collapsed = True)]   ,title = texttitle, collapsed = True)]
        #
        
    template.main.append(pn.Card(*out, title = 'Regional Association Plots', collapsed = True))
    
    faqtable = pd.read_parquet(self.phewas_db)[['project' ,'trait']].value_counts().to_frame().rename({0: 'number of SNPs'}, axis =1).reset_index()
    faqtext = '''Do the traits look approximately normally distributed? 
    
    * Our pipeline performs a quantile normalization, which is a transformation that preserves the rank of each subject but reassigns values such that the final distribution is perfectly normally distributed. When two or more subjects have identical values, the ‘tie’ is broken randomly (with a spefic random seed of 42), if there is a large proportion of ties, then that part of the distribution is random noise, which is bad (however, in our defense, there are no good solutions when multiple values are ties). 
    
    Are there extreme outliers that might be errors? 
    
    * By the time we send this report we would typically have tried to identify outliers/errors, but it is possible we’ve missed some so please let us know if you have concerns. 
    
    Are there sex differences? 
    
    * We regress out the effect of sex, so the GWAS essentially assumes that alleles have similar effects of the trait in males and females. This means we would not detect an interaction (e.g. an allele that affects a trait only in males). While it is possible to do GWAS for males and females separately, we don’t do this by default because the loss of power makes it hard to interpret the results. If sex differences are of major interest we can discuss ways of examining these.
    
    Which traits are included in the PheWAS database:'''
    faqtext = pn.pane.Markdown(faqtext)
    
    template.main.append(pn.Card(faqtext, fancy_display(faqtable), title = 'FAQ', collapsed = True))
    
    reftext = '''* Chitre AS, Polesskaya O, Holl K, Gao J, Cheng R, Bimschleger H, Garcia Martinez A, George T, Gileta AF, Han W, Horvath A, Hughson A, Ishiwari K, King CP, Lamparelli A, Versaggi CL, Martin C, St Pierre CL, Tripi JA, Wang T, Chen H, Flagel SB, Meyer P, Richards J, Robinson TE, Palmer AA, Solberg Woods LC. Genome-Wide Association Study in 3,173 Outbred Rats Identifies Multiple Loci for Body Weight, Adiposity, and Fasting Glucose. Obesity (Silver Spring). 2020 Oct;28(10):1964-1973. doi: 10.1002/oby.22927. Epub 2020 Aug 29. PMID: 32860487; PMCID: PMC7511439.'''
    template.main.append(pn.Card(reftext, title = 'References', collapsed = True))
    
    #template.main.append( pn.Card(pn.pane.Plotly(dashbio.Ideogram( id = 'test',  orientation='horizontal', organism = 'rat')), title = 'Chromosomes', collapsed=True))
    #template.main.append(
    #    [pn.Card(dfi_sine.hvplot(min_height=400).output(), title='Sine'),
    #    pn.Card(fancy_display(df))]
    #)
    template.header.append(f'## {self.project_name}')
    template.save(f'{self.path}results/gwas_report.html', resources=INLINE)
    bash(f'''cp {self.path}results/gwas_report.html {self.path}results/gwas_report_{self.project_name}_round{round_version}_threshold{threshold}_n{self.df.shape[0]}_date{datetime.today().strftime('%Y-%m-%d')}_gwasversion_{gwas_version}.html''')
    #printwithlog(f'{destination.replace("/tscc/projects/ps-palmer/s3/data", "https://palmerlab.s3.sdsc.edu")}/{self.project_name}/results/gwas_report.html')
    